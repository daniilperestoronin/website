Операторы управления потоком: for, if, else, switch и defer
Узнайте как управлять потоком выполнения программы с помощью условных выражений, циклов, конструкций switch и отложенных вызовов с defer.

Авторы Go
https://golang.org

* For

В Go есть только одна циклическая конструкция - цикл `for`.

Базовый цикл `for` имеет три компонента разделенные точкой с запятой:

- блок инициализации: выполняется перед первой итерацией
- условный блок: выполняется перед каждой итерацией
- завершающий блок: выполняется в конце каждой итерации

Блок инициализации, как правило, содержит краткое объявление переменных; переменные
объявленные здесь доступны только в области видимости цикла `for`.

Цикл прекратит итерации, как только значение логического выражения в условном блоке будет `false`.

_Замечание_: В отличие от таких языков как C, Java или Javascript блоки конструкции `for` не заключены в круглые скобки, а фигурные скобки `{`}` всегда обязательны.

.play flowcontrol/for.go

* For, продолжение

Блоки инициализации и завершения опциональны.

.play flowcontrol/for-continued.go

* For это "while" в Go

В таком случае вы можете опустить точки с запятой: в Go `for` это как `while` в C.

.play flowcontrol/for-is-gos-while.go

* Бесконечно

Если вы опустите условный блок, то получится компактная запись бесконечного цикла.

.play flowcontrol/forever.go

* If

Операторы `if` в Go такие же как и циклы `for`: выражение не должно быть заключено в круглые скобки `(`)`, но фигурные скобки `{`}` обязательны.

.play flowcontrol/if.go

* If с краткой инструкцией

Так же как и `for`, оператор `if` может начинаться с инструкции, которая будет выполнена перед проверкой условия.

Переменные объявленные в этом блоке доступны только в области видимости, которая существует до конца `if`.

(Попробуйте использовать `v` в последнем операторе `return`.)

.play flowcontrol/if-with-a-short-statement.go

* If и else

Переменные объявленные внутри краткой инструкции `if` также доступны внутри всех `else` блоков.

(Оба вызова `pow` выполняются и возвращают результат перед тем, как происходит вызов `fmt.Println` в `main`.)

.play flowcontrol/if-and-else.go

* Упражнение: циклы и функции

В качестве простого способа поэкспериментировать с функциями и циклами, реализуйте алгоритм нахождения квадратного корня методом Ньютона.

Метод Ньютона заключается в последовательном приближении `Sqrt(x)` путем выбора начального значения _z_, а затем повторения:

.image /content/img/newton.png

Для начала, просто повторите вычисления 10 раз и посмотрите, как близко вы к ответу для различных значений  (1, 2, 3, ...).

Затем измените условие цикла таким образом, чтобы остановиться, как только значение перестанет изменяться (или изменяется на очень малую величину). Посмотрите, получилось ли больше или меньше итераций. Насколько вы близки к [[https://golang.org/pkg/math/#Sqrt][math.Sqrt]]?

Подсказка: чтобы объявить и инициализировать значение с плавающей запятой, используйте либо синтаксис для значений с плавающей запятой, либо приведение типа:

	z := float64(1)
	z := 1.0

.play flowcontrol/exercise-loops-and-functions.go

* Switch

Вероятно вы уже догадались, на что будет похож `switch`.

Блок `case` прерывается автоматически, только если он не заканчивается оператором `fallthrough`.

.play flowcontrol/switch.go

* Порядок выполнения Switch

Условия блоков `case` проверяются сверху вниз до тех пор, пока одно из них не будет успешным.

(Например,

	switch i {
	case 0:
	case f():
	}

не вызывает `f` если `i==0`.)

#appengine: *Замечание:* В песочнице Go время начинается со значения
#appengine: 2009-11-10 23:00:00 UTC, определение значимости которого оставляется в качестве
#appengine: упражнения для читателя.

.play flowcontrol/switch-evaluation-order.go

* Switch без условия

Switch без условия это тоже самое, что и `switch`true`.

Эта конструкция может быть использована как более ясный способ записи длинной цепочки if-then-else.

.play flowcontrol/switch-with-no-condition.go

* Defer

Оператор `defer` откладывает выполнение функции до того момента, как произойдет возврат из окружающей функции.

Аргументы отложенных вызовов вычисляются сразу же, но вызов функции не происходит до того, как произойдет возврат из окружающей функции.

.play flowcontrol/defer.go

* Накопление отложенных вызовов

Отложенные вызовы функций сохраняются в стеке. Когда происходит возврат из функции, ее отложенные вызовы выполняются в порядке "последним-пришел-первым-вышел".

Чтобы узнать больше об отложенных вызовах прочтите этот [[https://blog.golang.org/defer-panic-and-recover][пост в блоге]].

.play flowcontrol/defer-multi.go

* Поздравляем!

Вы закончили этот урок!

Вы можете вернуться к списку [[/list][модулей]], чтобы найти, что изучить дальше, или перейдите к [[javascript:click('.next-page')][следующему уроку]].