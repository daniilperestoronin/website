Еще типы: структуры, срезы и карты (словари).
Узнайте как определять новые типы основанные на существующих: в этом уроке рассматриваются структуры, массивы, срезы и карты (словари).

Авторы Go
https://golang.org

* Указатели

В Go есть указатели.
Указатель содержит адрес переменной в памяти.

Тип `*T` это указатель на значение `T`. Его нулевое значение `nil`.

	var p *int

Оператор `&` возвращает указатель на его операнд.

	i := 42
	p = &i

Оператор `*` дает доступ к лежащему в основе значению указателя.

	fmt.Println(*p) // прочитать i через указатель p
	*p = 21         // установить i через указатель p

Это известно как "разыменование" и "присваивание".

В отличие от C, в Go нет адресной арифметики.

.play moretypes/pointers.go

* Структуры

`struct` это коллекция полей.

.play moretypes/structs.go

* Поля структуры

Доступ к полям структуры производится с помощью точки.

.play moretypes/struct-fields.go

* Указатели на структуры

Доступ к полям структуры может быть получен через указатель на структуру.

Чтобы получить поле `X` структуры, когда у нас есть указатель на структуру `p`, мы можем
написать `(*p).X`.
Однако такая запись громоздка, поэтому язык позволяет нам просто
писать `p.X`, без явного разыменования.

.play moretypes/struct-pointers.go

* Литералы структур

Литерал структуры определяет новую структуру путем перечисления значений ее полей.

Вы можете перечислить не все поля, а лишь некоторое подмножество с помощью синтаксиса `Name:`. (Тогда порядок именованных полей не имеет значения.)

Специальный префикс `&` возвращает указатель на структуру.

.play moretypes/struct-literals.go


* Массивы

Тип `[n]T` обозначает массив из `n` значений типа `T`.

Выражение

	var a [10]int

объявляет переменную `a` как массив из десяти целых чисел.

Размер (длина) массива является частью типа, поэтому размер массива не может быть изменен.
Это может показаться ограничением, но не беспокойтесь;
Go предоставляет удобный способ работы с массивами.

.play moretypes/array.go


* Срезы

Массивы имеют фиксированный размер.
Срез - это гибкое отображение элементов массива
с возможностью динамического изменения размера.
На практике срезы более распространены, чем массивы.

Тип `[]T` обозначает срез с элементами типа `T`.

Это выражение создает срез из пяти первых элементов массива `a`:

	a[0:5]


.play moretypes/slices.go


* Срезы это как указатели на массивы

Срез не хранит никаких данных,
он всего лишь обозначает секцию лежащего в основе массива.

Изменения элементов среза приводят к модификации
соответствующих элементов лежащего в его основе массива.

Другие срезы, имеющие общий лежащий в основе массив, также увидят эти изменения.

.play moretypes/slices-pointers.go


* Литералы срезов

Литерал среза такой же как и для массива, но без размера.

Вот пример создания массива:

	[3]bool{true, true, false}


Здесь будет создан такой же массив, как и выше,
а затем построен срез, ссылающийся на него:

	[]bool{true, true, false}

.play moretypes/slice-literals.go


* Значения по умолчанию в срезах

Когда вы хотите создать срез, то можете опустить верхнюю или нижнюю границы, чтобы использовать значения по умолчанию.

Значением по умолчанию для нижней границы является нуль, а для верхней - размер среза.

Для массива

	var a [10]int

следующие выражения создания среза эквивалентны:

	a[0:10]
	a[:10]
	a[0:]
	a[:]

.play moretypes/slice-bounds.go


* Размер и вместимость среза

Срез имеет _размер_ (_длину_) и _вместимость_.

Размер среза - это количество элементов, которые он содержит.

Вместимость среза - это количество элементов в лежащем в его основе массиве,
начиная с первого элемента в срезе.

Размер и вместимость среза `s` могут быть получены с помощью
`len(s)` и `cap(s)`.

Размер среза может быть увеличен путем повторной операции "срезания",
при условии, что он обладает достаточной вместимостью.
Попробуйте изменить одну из операций над срезом в данной программе, чтобы расширить его за пределы вместимости и посмотрите, что будет.

.play moretypes/slice-len-cap.go


* Нулевые срезы

Нулевым значением среза является `nil`.

Длина и вместимость нулевого среза равны 0,
и он не имеет лежащего в основе массива.

.play moretypes/nil-slices.go


* Создание среза с помощью make

Срезы могут быть созданы с помощью встроенной функции `make`;
вот как вы создаете массивы с динамическим размером.

Функция `make` создает обнуленный массив
и возвращает срез, который ссылается на этот массив.

	a := make([]int, 5)  // len(a)=5

Чтобы указать вместимость, укажите третий аргумент к `make`:

	b := make([]int, 0, 5) // len(b)=0, cap(b)=5

	b = b[:cap(b)] // len(b)=5, cap(b)=5
	b = b[1:]      // len(b)=4, cap(b)=4

.play moretypes/making-slices.go


* Срезы срезов

Срезы могут содержать данные любого типа, в том числе и другие срезы.

.play moretypes/slices-of-slice.go


* Добавление к срезу

Необходимость добавления новых элементов к срезу возникает часто, и Go предоставляет встроенную
функцию `append`. [[https://golang.org/pkg/builtin/#append][Документация]]
по встроенному пакету описывает `append`.

	func append(s []T, vs ...T) []T

Первый параметр `s` для `append` это срез элементов типа `T`, а остальные - значения
типа `T` для добавления к срезу.

Результатом `append` является срез, который содержит все элементы
оригинального среза, а также новые значения.

Если лежащий в основе массив среза `s` слишком мал, чтобы вместить все значения, то
 будет создан новый массив большего размера. Результирующий срез будет ссылаться на этот
 новый массив.

(Чтобы узнать больше о срезах, прочтите статью [[https://blog.golang.org/go-slices-usage-and-internals][Срезы: использование и внутреннее устройство]].)

.play moretypes/append.go


* Range

Итерация по срезу или карте производится с помощью формы цикла `for` с ключевым словом `range`.

На каждой итерации по срезу возвращаются два значения.
Первое - это индекс, а второе - копия элемента по этому индексу.

.play moretypes/range.go

* Range, продолжение

Вы можете опустить индекс или значение путем его присвоения к `_`.

Если вам нужен только индекс, опустите ", value" полностью.

.play moretypes/range-continued.go

* Упражнение: срезы

Реализуйте `Pic`. Она должна возвращать срез размером `dy`, каждый элемент которого это срез из `dx` 8-битных беззнаковых целых чисел. Когда вы запустите программу, она покажет изображение, интерпретируя целые числа как оттенки серого  (вообще-то, синего).

Выбор изображения за вами. Среди интересных функций `(x+y)/2`, `x*y` и `x^y`.

(Необходимо использовать цикл, чтобы создать каждый `[]uint8` внутри `[][]uint8`.)

(Используйте `uint8(intValue)` для приведения типов.)

.play moretypes/exercise-slices.go

* Карты (словари)

Карта ассоциирует ключ и значение.

Нулевое значение карты это `nil`.
Нулевая карта не содержит ключи, и ключи не могут быть добавлены.

Функция `make` возвращает карту заданного типа,
инициализированную и готовую к использованию.

.play moretypes/maps.go

* Литералы карт

Литералы карт похожи на литералы структур, но ключи обязательны.

.play moretypes/map-literals.go

* Литералы карт, продолжение

Если тип верхнего уровня всего лишь имя типа, то вы можете не указывать его для элементов литерала.

.play moretypes/map-literals-continued.go

* Изменения карт

Добавление или изменение элемента карты `m`:

	m[key] = elem

Получить элемент:

	elem = m[key]

Удалить элемент:

	delete(m, key)

Проверить, что ключ присутствует с помощью присвоения двух значений:

	elem, ok = m[key]

Если `key` присутствует в `m`, `ok` будет `true`. Если нет, `ok` - `false`.

Если `key` не присутствует в карте, то `elem` будет нулевым значением типа элементов карты.

_Примечание_: если `elem` или `ok` не были объявлены, то вы можете использовать краткую форму:

	elem, ok := m[key]

.play moretypes/mutating-maps.go

* Упражнение: карты

Реализуйте `WordCount`. Она должна вернуть карту с количеством повторений каждого "слова" в строке `s`. Функция `wc.Test` запускает набор тестов для предоставленной функции и выводит сообщение об успехе или неудаче.

Возможно, вам пригодится [[https://golang.org/pkg/strings/#Fields][strings.Fields]].

.play moretypes/exercise-maps.go

* Функция как значение

Функции тоже являются значениями. Их можно передавать так же как и остальные значения.

Функции могут быть использованы как аргументы других функций и как возвращаемые значения.

.play moretypes/function-values.go

* Замыкания

В Go функции могут быть замыканиями. Замыкание - это функция, которая ссылается к переменным вне ее тела. Функция имеет доступ к связанным переменным, а также может присваивать им значения; в этом смысле функция "связана" с этими переменными.

Например, функция `adder` возвращает замыкание. Каждое замыкание связано со своей собственной переменной `sum`.

.play moretypes/function-closures.go

* Упражнение: замыкание Фибоначчи

Давайте повеселимся с функциями.

Реализуйте функцию `fibonacci`, которая возвращает функцию (замыкание), которая возвращает
последовательные [[https://en.wikipedia.org/wiki/Fibonacci_number][числа Фибоначчи]]
(0, 1, 1, 2, 3, 5, ...).

.play moretypes/exercise-fibonacci-closure.go

* Поздравляем!

Вы закончили этот урок!

Вы можете вернуться к списку [[/list][модулей]], чтобы найти, что изучить дальше, или перейдите к [[javascript:click('.next-page')][следующему уроку]].