Методы и интерфейсы
Этот урок рассматривает методы и интерфейсы: конструкции, которые определяют объекты и их поведение.

Авторы Go
https://golang.org

* Методы

В Go нет классов.
Тем не менее, вы можете объявлять методы для типов.

Метод - это функция со специальным аргументом, известным как _получатель_.

Получатель указывается в отдельном списке аргументов между ключевым словом `func` и
именем метода.

В данном примере метод `Abs` имеет получателя с типом `Vertex` и именем `v`.

.play methods/methods.go

* Методы и функции

Запомните: метод - это всего лишь функция, для которой указан получатель.

В этом примере `Abs` является обычной функцией с тем же функционалом.

.play methods/methods-funcs.go

* Методы, продолжение

Вы также можете объявлять методы не только для структур.

В данном примере мы видим числовой тип `MyFloat` и его метод `Abs`.

Вы можете объявить метод только с получателем, чей тип объявлен в том же
пакете, что и сам метод.
Вы не можете объявить метод с получателем, чей тип объявлен в другом
пакете (что также верно для встроенных типов, таких как `int`).

.play methods/methods-continued.go

* Получатели и указатели

Вы можете объявлять методы, где в качестве получателей выступают указатели.

Это означает, что получатель объявлен как `*T` для некоторого типа `T`.
(И еще, `T` не может быть указателем сам по себе, как, например, `*int`.)

Например, метод `Scale` в данном примере объявлен для `*Vertex`.

Методы с получателями-указателями могут модифицировать значение, на которое
указывает получатель (как делает `Scale` в данном примере).
Т.к. методам часто необходимо модифицировать получателя, то
использование указателей более частая практика, чем получатели как значения.

Попробуйте убрать `*` из объявления функции `Scale` на строке 16
и понаблюдайте, как изменяется поведение программы.

При использовании получателя-значения, метод `Scale` работает с копией оригинального
значения `Vertex`.
(Это такое же поведение, как и для любого другого аргумента функции.)
Метод `Scale` должен иметь указатель на получателя для того, чтобы изменить значение `Vertex`,
объявленное в функции `main`.

.play methods/methods-pointers.go

* Указатели и функции

Здесь мы видим методы `Abs` и `Scale` переписанные в качестве функций.

Еще раз, попробуйте убрать `*` из строки 16.
Можете понять, почему поведение изменилось?
Что еще вы должны изменить в этом примере, чтобы он заработал?

(Если вы не уверены, перейдите к следующей странице.)

.play methods/methods-pointers-explained.go

* Методы и косвенная адресация указателей

Сравнивая две предыдущие программы, вы могли обратить внимание,
что функции с аргументом указателем должны принимать указатель:

	var v Vertex
	ScaleFunc(v)  // Ошибка компиляции!
	ScaleFunc(&v) // OK

тогда как методы объявленные с получателем-указателем могут принимать как значение, так и указатель при вызове:

	var v Vertex
	v.Scale(5)  // OK
	p := &v
	p.Scale(10) // OK

В выражении `v.Scale(5)`, хотя `v` является значением, а не указателем,
метод с получателем-указателем вызывается автоматически.
Это потому, что Go в качестве удобства интерпретирует `v.Scale(5)` как
`(&v).Scale(5)`, т.к. метод `Scale` объявлен для получателя-указателя.

.play methods/indirection.go

* Методы и косвенная адресация указателей (2)

То же самое происходит и в обратном направлении.

Функции с аргументом значением должны принимать значение конкретного типа:

	var v Vertex
	fmt.Println(AbsFunc(v))  // OK
	fmt.Println(AbsFunc(&v)) // Ошибка компиляции!

тогда как методы с получателем-значением могут принимать как значение, так и указатель при вызове:

	var v Vertex
	fmt.Println(v.Abs()) // OK
	p := &v
	fmt.Println(p.Abs()) // OK

В этом случае вызов метода `p.Abs()` интерпретируется как `(*p).Abs()`.

.play methods/indirection-values.go

* Выбирая между получателем как значение или указателем

Есть две причины, чтобы использовать указатель для получателя.

Во-первых, метод может изменять значение, на которое ссылается указатель.

Во-вторых, тем самым можно избежать копирования значения при каждом вызове метода.
Это может быть более эффективно, если получателем является большая структура, например.

В данном примере у `Scale` и `Abs` в качестве получателя указан тип `*Vertex`,
хотя метод `Abs` не имеет необходимости изменять получателя.

В общем, все методы для типа должны иметь либо значение, либо указатель в качестве
получателя, но не оба сразу.
(Мы увидим почему на следующих страницах.)

.play methods/methods-with-pointer-receivers.go

* Интерфейсы

_Тип_интерфейс_ определяется набором сигнатур его методов.

Значение типа интерфейса может содержать любое значение, реализующее эти методы.

*Замечание:* В примере на строке 22 есть ошибка.
`Vertex` (тип значения) не реализует интерфейс `Abser`, потому что
метод `Abs` объявлен только для `*Vertex` (для указателя на тип).

.play methods/interfaces.go

* Интерфейсы реализуются неявно

Тип реализует интерфейс путем реализации всех его методов.
Нет явного объявления о намерении реализовать интерфейс, и нет ключевого слова "implements".

Неявные интерфейсы отделяют объявление интерфейса от его
реализаций, которые могут находиться в любом другом пакете без предварительных согласований.

.play methods/interfaces-are-satisfied-implicitly.go

* Интерфейсные значения

Интерфейсное значение можно рассматривать как пару из значения и конкретного типа:

	(value, type)

Интерфейсное значение содержит значение конкретного лежащего в основе типа.

Вызов метода интерфейсного значения выполняет метод с таким же именем у его лежащего в основе типа.

.play methods/interface-values.go

* Интерфейсные значения с лежащим в основе значением nil

Если лежащим в основе значением интерфейсного значения является nil,
то метод будет вызван с получателем nil.

В некоторых языках это привело бы к исключению нулевого указателя,
но в Go обычно пишут методы, которые обрабатывают ситуацию, когда они вызваны
с получателем nil (как в случае с методом `M` в данном примере).

Обратите внимание, что если интерфейсное значение имеет nil в качестве лежащего в основе значения, то само по себе оно не nil.

.play methods/interface-values-with-nil.go

* Интерфейсное значение nil

Интерфейсное значение nil не содержит ни значения, ни конкретного типа.

Вызов метода у nil интерфейса является ошибкой времени выполнения, т.к. внутри
пары значение/тип нет типа, чтобы указать, какой _конкретный_ метод надо вызвать.

.play methods/nil-interface-values.go

* Пустой интерфейс

Интерфейс, который не содержит ни одного метода называется _пустым_интерфейсом_:

	interface{}

Пустой интерфейс может содержать значение любого типа.
(Каждый тип реализует по меньшей мере нуль методов.)

Пустые интерфейсы используются в коде, где необходимо работать со значениями неизвестного типа.
Например, `fmt.Print` принимает любое количество аргументов типа `interface{}`.

.play methods/empty-interface.go

* Утверждение типа

_Утверждение_типа_ дает доступ к конкретному лежащему в основе значению интерфейсного значения.

	t := i.(T)

Эта инструкция утверждает, что интерфейсное значение `i` содержит конкретное значение типа `T`,
и присваивает лежащее в основе значение `T` переменной `t`.

Если `i` не содержит `T`, то это приведет к panic.

Чтобы _проверить_, содержит ли интерфейсное значение конкретный тип,
оператор приведения типа может вернуть два значения: лежащее в основе значение
и булевое значение, указывающее, была ли операция приведения типа успешной.

	t, ok := i.(T)

Если `i` содержит `T`, то `t` будет лежащим в основе значением и `ok` будет true.

Если нет, то `ok` будет false и `t` будет нулевым значением типа `T`,
и не будет panic.

Обратите внимание на сходство между этим синтаксисом и чтением из карты.

.play methods/type-assertions.go

* Switch с типами

_Switch_с_типами_ это конструкция, которая позволяет несколько операций приведения типа подряд.

Этот тип switch выглядит как и обычный оператор switch, но в качестве меток в блоках `case`
выступают типы (не значения), и эти типы сравниваются с типом
лежащего в основе значения интерфейсного значения.

	switch v := i.(type) {
	case T:
		// здесь v имеет тип T
	case S:
		// здесь v имеет тип S
	default:
		// нет совпадения; здесь v имеет такой же тип, что и i
	}

Объявление в таком варианте switch имеет такой же синтаксис, что и приведение типа `i.(T)`,
но конкретный тип `T` заменяется ключевым словом `type`.

Оператор switch проверяет, содержит ли интерфейсное значение `i`
значение типа `T` или `S`.
В обоих случаях: как `T`, так и `S`, переменная `v` будет либо типа
`T`, либо соответственно `S` и будет содержать значение, которое было в `i`.
В ветке default (где нет совпадения), переменная `v`
такого же типа и значения, что и  `i`.

.play methods/type-switches.go

* Stringers

Одним из наиболее часто встречающихся интерфейсов является [[//golang.org/pkg/fmt/#Stringer][`Stringer`]], объявленный в пакете [[//golang.org/pkg/fmt/][`fmt`]].

	type Stringer interface {
		String() string
	}

`Stringer` это тип, который может описать себя строкой. Пакет `fmt`
(и многие другие) ожидают этот интерфейс для вывода значений.

.play methods/stringer.go

* Упражнение: Stringers

Сделайте так, чтобы тип `IPAddr` реализовывал `fmt.Stringer`, чтобы выводить адрес как четыре значения,
разделенные точкой.

Например, `IPAddr{1,`2,`3,`4}` должен быть напечатан как `"1.2.3.4"`.

.play methods/exercise-stringer.go

* Ошибки

Программы на Go выражают состояние ошибки с помощью значения типа `error`.

Тип `error` является встроенным типом, таким же как и `fmt.Stringer`:

	type error interface {
		Error() string
	}

(Как и в случае с `fmt.Stringer`, пакет `fmt` ожидает интерфейс `error`,
когда выводит значения.)

Функции часто возвращает значения типа `error`, а проверяющему коду следует обрабатывать ошибки
проверяя, является ли error равным `nil`.

	i, err := strconv.Atoi("42")
	if err != nil {
		fmt.Printf("ошибка конвертации числа: %v\n", err)
		return
	}
	fmt.Println("Сконвертированное целое число:", i)

`error` равное nil означает успех; не-nil значение `error` означает неудачу.

.play methods/errors.go

* Упражнение: ошибки

Скопируйте вашу функцию `Sqrt` из [[/flowcontrol/8][более раннего упражнения]] и модифицируйте ее, чтобы она возвращала значение `error`.

`Sqrt` должна вернуть не-nil значение ошибки, когда получает на вход отрицательное число, т.к. не поддерживает комплексные числа.

Создайте новый тип

	type ErrNegativeSqrt float64

и сделайте его `error`, объявив для него метод

	func (e ErrNegativeSqrt) Error() string

такой, что `ErrNegativeSqrt(-2).Error()` возвращает `"cannot`Sqrt`negative`number:`-2"`.

*Замечание:* вызов `fmt.Sprint(e)` внутри метода `Error` отправит программу в бесконечный цикл. Вы можете избежать этого сконвертировав для начала `e`: `fmt.Sprint(float64(e))`. Почему?

Измените вашу функцию `Sqrt`, чтобы она возвращала значение `ErrNegativeSqrt`, когда получает на вход отрицательное число.

.play methods/exercise-errors.go

* Reader

Пакет `io` объявляет интерфейс `io.Reader`,
который представляет сторону потока данных, предназначенную для чтения.

Стандартная библиотека Go содержит [[https://golang.org/search?q=Read#Global][множество реализаций]] этого интерфейса, включая файлы, сетевые соединения, компрессоры, шифрователи и другие.

Интерфейс `io.Reader` имеет метод `Read`:

	func (T) Read(b []byte) (n int, err error)

`Read` записывает данные в предоставленный срез байтов и возвращает количество записанных байтов
и значение типа error. Он возвращает ошибку `io.EOF`, когда поток заканчивается.

Данный пример кода создает
[[//golang.org/pkg/strings/#Reader][`strings.Reader`]]
и считывает его вывод по 8 байтов за раз.

.play methods/reader.go

* Упражнение: Reader

Реализуйте тип `Reader`, генерирующий бесконечный поток ASCII символа
`'A'`.

.play methods/exercise-reader.go

* Упражнение: rot13Reader

Обычной практикой является реализация [[https://golang.org/pkg/io/#Reader][io.Reader]], которая "оборачивает" другой `io.Reader`, модифицируя поток некоторым образом.

Например, функция [[https://golang.org/pkg/compress/gzip/#NewReader][gzip.NewReader]] принимает `io.Reader` (поток сжатых данных) и возвращает `*gzip.Reader`, который также реализует `io.Reader` (поток декомпрессированных данных).

Реализуйте `rot13Reader`, который реализует `io.Reader` и читает из `io.Reader`, модифицируя поток путем применения шифра подстановки [[https://en.wikipedia.org/wiki/ROT13][rot13]] ко всем алфавитным символам.

Тип `rot13Reader` вам уже предоставляется.
Сделайте его `io.Reader`, реализуя его метод `Read`.

.play methods/exercise-rot-reader.go

* Изображения

[[https://golang.org/pkg/image/#Image][Пакет image]] объявляет интерфейс `Image`:

	package image

	type Image interface {
		ColorModel() color.Model
		Bounds() Rectangle
		At(x, y int) color.Color
	}

*Замечание*: возвращаемое значение `Rectangle` метода `Bounds` на самом деле
[[https://golang.org/pkg/image/#Rectangle][`image.Rectangle`]], т.к.
его объявление находится внутри пакета `image`.

(Детали смотрите в [[https://golang.org/pkg/image/#Image][документации]].)

Типы `color.Color` и `color.Model` также являются интерфейсами, но мы проигнорируем это, и будем использовать определенные заранее реализации `color.RGBA` и `color.RGBAModel`. Эти интерфейсы и типы объявлены в [[https://golang.org/pkg/image/color/][пакете image/color]]

.play methods/images.go

* Упражнение: изображения

Помните генератор изображения, который вы написали ранее? Давайте напишем еще один, но на этот раз он будет возвращать реализацию `image.Image` вместо среза данных.

Объявите ваш собственный тип `Image`, реализуйте [[https://golang.org/pkg/image/#Image][необходимые методы]], и вызовите `pic.ShowImage`.

`Bounds` должен возвращать `image.Rectangle`, например `image.Rect(0,`0,`w,`h)`.

`ColorModel` должен возвращать `color.RGBAModel`.

`At` должен возвращать цвет; значение `v` в последнем генераторе изображения соответствует `color.RGBA{v,`v,`255,`255}` в текущем.

.play methods/exercise-images.go

* Поздравляем!

Вы закончили этот урок!

Вы можете вернуться к списку [[/list][модулей]], чтобы найти, что изучить дальше, или перейдите к [[javascript:click('.next-page')][следующему уроку]].