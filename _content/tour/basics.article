Пакеты, переменные и функции.
Изучите базовые компоненты любой программы на Go.

Авторы Go
https://golang.org

* Пакеты

Каждая программа на Go состоит из пакетов.

Программа начинает работу в пакете `main`.

Эта программа использует пакеты с путями импорта `"fmt"` и `"math/rand"`.

По соглашению, имя пакета совпадает с последним элементом пути импорта. Например, пакет `"math/rand"` состоит из файлов, которые начинаются с оператора `package`rand`.

#appengine: *Замечание:* окружение, в котором выполняются эти программы,
#appengine: заранее предопределено, так что каждый раз, когда вы запускаете пример
#appengine: `rand.Intn` будет возвращать одно и то же число.
#appengine:
#appengine: (Чтобы получить другое число, инициализируйте генератор случайных чисел; подробнее [[https://golang.org/pkg/math/rand/#Seed][`rand.Seed`]].)

.play basics/packages.go

* Импорты

Этот код группирует импорты в один import оператор с помощью скобочек.

Вы также можете использовать несколько import операторов:

	import "fmt"
	import "math"

Но хорошим тоном считается использование группированного import оператора.

.play basics/imports.go

* Экспортированные имена

В Go имя экспортируется, если оно начинается с заглавной буквы.
Например, `Pizza` это экспортируемое имя, так же как и `Pi`, которое экспортируется
из пакета `math`.

`pizza` и `pi` не начинаются с заглавной буквы, поэтому они не экспортируются.

Когда вы импортируете пакет, то можете ссылаться только на его экспортируемые имена.
Любые не экспортированные имена недоступны за пределами пакета.

Запустите код. Обратите внимание на сообщение об ошибке.

Чтобы исправить ошибку, переименуйте `math.pi` в `math.Pi` и попробуйте снова.

.play basics/exported-names.go

* Функции

Функция может принимать нуль или более аргументов.

В этом примере `add` принимает два параметра типа `int`.

Обратите внимание, что тип указывается _после_ имени переменной.

(Чтобы узнать, почему типы выглядят так, как они выглядят, прочтите [[https://blog.golang.org/gos-declaration-syntax][статью про объявление типов в Go]].)

.play basics/functions.go

* Функции, продолжение

Когда два или более последовательных параметра функции имеют одинаковый тип, вы можете опустить указание типа для всех, кроме последнего.

В этом примере мы сократили

	x int, y int

до

	x, y int

.play basics/functions-continued.go

* Множественные результаты

Функция может возвращать любое количество результатов.

Функция `swap` возвращает две строки.

.play basics/multiple-results.go

* Именованные возвращаемые значения

В Go возвращаемые значения могут быть именованными. В этом случае они расцениваются как переменные объявленные в начале функции.

Эти имена следует использовать для документирования смысла возвращаемых значений.

`return` без аргументов возвращает именованные возвращаемые значения, что известно как "голый" возврат.

Такой способ возврата значений следует использовать только в коротких функциях, как в представленном здесь примере. В более длинных функциях это может ухудшить читаемость.

.play basics/named-results.go

* Переменные

Оператор `var` объявляет список переменных; как и в случае со списком аргументов функции, тип указывается последним.

Оператор `var` может быть использован на уровне пакета или функции. В данном примере мы видим оба варианта.

.play basics/variables.go

* Переменные с инициализирующими значениями

Объявление переменной может включать инициализирующее значение, по одному на каждую переменную.

Если инициализирующее значение присутствует, то тип может быть опущен; переменная получит тип этого значения.

.play basics/variables-with-initializers.go

* Краткая форма объявления переменных

Внутри функции, краткий оператор присваивания `:=` с неявным типом может быть использован вместо объявления с помощью `var`.

Вне функции, каждый оператор начинается с ключевого слова (`var`, `func`, и так далее), и поэтому конструкция `:=` недоступна.

.play basics/short-variable-declarations.go

* Базовые типы

Базовые типы Go следующие

	bool

	string

	int  int8  int16  int32  int64
	uint uint8 uint16 uint32 uint64 uintptr

	byte // псевдоним для uint8

	rune // псевдоним для int32
	     // представляет Unicode код

	float32 float64

	complex64 complex128

Пример демонстрирует переменные нескольких типов, а также то, что объявления переменных могут быть сгруппированы в блоки, так же как и операторы import.

Типы `int`, `uint`, и `uintptr` обычно размером 32 бита на 32-битных системах и 64 бита на 64-битных системах.
Когда вам необходимо целочисленное значение, то следует использовать `int`, если у вас нет особой причины использовать целочисленное значение конкретного размера или беззнаковое значение.

.play basics/basic-types.go

* Нулевые значения

Переменные объявленные без указания начального значения получают _нулевое_значение_.

Нулевое значение это:

- `0` для числовых типов,
- `false` для булевого типа, и
- `""` (пустая строка) для строк.

.play basics/zero.go

* Приведение типа

Выражение `T(v)` приводит значение `v` к типу `T`.

Примеры для числовых типов:

	var i int = 42
	var f float64 = float64(i)
	var u uint = uint(f)

Или проще:

	i := 42
	f := float64(i)
	u := uint(f)

В отличие от C, в Go присвоения между элементами различных типов требуют явного приведения типов.
Попробуйте удалить `float64` или `uint` в примере и посмотрите, что будет.

.play basics/type-conversions.go

* Выведение типа

При объявлении переменной без явного указания типа (с помощью `:=` или `var`=`), тип переменной выводится из значения на правой стороне.

Когда правая часть объявления типизирована, новая переменная получает такой же тип:

	var i int
	j := i // j это int

Но когда правая часть содержит нетипизированную числовую константу, новая переменная может быть `int`, `float64`, или `complex128` в зависимости от точности константы:

	i := 42           // int
	f := 3.142        // float64
	g := 0.867 + 0.5i // complex128

Попробуйте изменить начальное значение `v` в примере и понаблюдайте, как изменяется ее тип.

.play basics/type-inference.go

* Константы

Константы объявляются как переменные, но с помощью ключевого слова `const`.

Константы могут иметь символьные, строковые, булевые или числовые значения.

Константы не могут быть объявлены с помощью синтаксиса `:=`.

.play basics/constants.go

* Числовые константы

Числовые константы это _значения_ высокой точности.

Нетипизированная константа принимает тип, необходимый в ее контексте.

Попробуйте также вывести `needInt(Big)`.

(`int` может максимум хранить 64-битное целочисленное значение, а иногда меньше.)

.play basics/numeric-constants.go

* Поздравляем!

Вы закончили этот урок!

Вы можете вернуться к списку [[/list][модулей]], чтобы найти, что изучить дальше, или перейдите к [[javascript:click('.next-page')][следующему уроку]].